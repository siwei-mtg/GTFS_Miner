# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GTFS_miner
                                 A QGIS plugin
 Extraction facile des données GTFS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-11-08
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Wei SI Transamo
        email                : wei.si@transamo.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QFileDialog,QProgressBar

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .GTFS_miner_dialog import GTFS_minerDialog
from .data_transformation import *
from .data_quality_check import *
from .geometries import *
import os
from datetime import datetime
import time
import logging



class GTFS_miner:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GTFS_miner_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GTFS Miner')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GTFS_miner', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/GTFS_miner/Resources/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'GTFS Miner'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GTFS Miner'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_input_dir(self):
        input_dirname = QFileDialog.getExistingDirectory(self.dlg, "Sélectionnez le dossier des fichiers sources")
        if len(input_dirname) >0 :
            self.dlg.lineEdit_input.setText(input_dirname)

    def select_output_dir(self):
        output_dirname = QFileDialog.getExistingDirectory(self.dlg, "Sélectionnez le dossier des fichiers traités")
        if len(output_dirname) >0 :
            self.dlg.lineEdit_output.setText(output_dirname)


    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GTFS_minerDialog()
        # Initialize dialog interface
        self.dlg.initDialog()
        # Connect signals
        self.dlg.connectSignals(self.select_input_dir, self.select_output_dir, self.lancer,self.test) 
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            self.dlg.resetFields()
            self.dlg.disconnectSignals()

    def userInput(self):
        # User Input
        rawPath = self.dlg.lineEdit_input.text() # Input path of user selection
        output_path = self.dlg.lineEdit_output.text() # Output path of user selection
        time1 =self.dlg.timeEditDebutHPM.time() # User input time bin for periods
        time2 =self.dlg.timeEditFinHPM.time()
        time3 =self.dlg.timeEditDebutHPS.time()
        time4 =self.dlg.timeEditFinHPS.time()
        type_vac = self.dlg.comboBox_zonevac.currentText()
        debut_hpm = time1.hour()/24 + time1.hour()/24/60
        fin_hpm = time2.hour()/24 + time2.hour()/24/60
        debut_hps = time3.hour()/24 + time3.hour()/24/60
        fin_hps = time4.hour()/24 + time4.hour()/24/60
        user_inputs = {'rawPath':rawPath,
                       'output_path':output_path,
                       'type_vac':type_vac,
                       'debut_hpm':debut_hpm,
                       'fin_hpm':fin_hpm,
                       'debut_hps':debut_hps,
                       'fin_hps':fin_hps}
        return user_inputs
    


    def lancer(self):
        # Affichage en fonction de la sélection utilisateur
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Traitement des données GTFS vient de commencer!")
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Le processus peut durer environ 5 - 10 minutes. Si QGIS ne répond plus, c'est normal. Prenez un café en attendant.")
        t0 = round(time.time(),2)
        nb_erreurs = 0
        # Read raw data
        user_inputs = self.userInput()

        # Set up logging to output directory
        log_file_path = os.path.join(user_inputs['output_path'], 'traitement.log')
        logger = logging.getLogger(self.__class__.__name__)  # Logger name based on the class
        logger.setLevel(logging.DEBUG)

        # Set up file handler
        file_handler = logging.FileHandler(log_file_path)
        formatter = logging.Formatter('%(asctime)s:%(name)s:%(message)s')
        file_handler.setFormatter(formatter)
        
        # Set up stream handler (for console output)
        stream_handler = logging.StreamHandler()
        stream_handler.setFormatter(formatter)
        
        # Adding handlers to logger
        logger.addHandler(file_handler)
        logger.addHandler(stream_handler)

        logger.info("Traitement des données GTFS commence...")
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Lire les données brutes GTFS depuis le dossier choisi...")

        # Ingestion données brutes
        try:
            recap,raw = read_raw_data(user_inputs['rawPath'])
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: récap des tables lu : \n {recap}")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la lecture des données brutes, avec la fonction read_raw_data: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")
        
        Dates = read_date(self.plugin_dir)
        # Créer tables données normalisées
        try:
            GTFS_norm = normalize_raw_data(raw)
            self.dlg.progressBar.setValue(5)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Lecture des données brutes terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la lecture des données brutes, avec la fonction normalize_raw_data: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")
        
        stops = GTFS_norm['stops']
        routes = GTFS_norm['routes']
        stop_times = GTFS_norm['stop_times']
        initial_na = GTFS_norm['initial_na']
        final_na_time_col = GTFS_norm['final_na_time_col']
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Voici les colonnes ayant valeur NA dans la table Stop_times: {initial_na}")
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Nombre de NA dans les colonnes 'arrival_time' and 'departure_time' après traitement: {final_na_time_col}.")

        trips = GTFS_norm['trips']
        calendar = GTFS_norm['calendar']
        calendar_dates = GTFS_norm['calendar_dates']
        route_id_coor= GTFS_norm['route_id_coor']
        trip_id_coor = GTFS_norm['trip_id_coor']
        ser_id_coor = GTFS_norm['ser_id_coor']

        all_tables = " ; ".join(str(key) for key in GTFS_norm.keys())
        shapes_exist = "shapes" in GTFS_norm.keys()
        if shapes_exist:
            shapes =  GTFS_norm['shapes']
            shapes['shape_id'] = shapes['shape_id'].astype(str)
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Les fichiers présents dans le jeu de données GTFS sont les suivants: {all_tables}.")        
        del GTFS_norm

        # Créer tables arrêts génériques et physiques
        ## format standard
        try:
            AP, AG, marker = ag_ap_generate_reshape(stops)
            ## Ecriture en csv
            AG.to_csv(f"{user_inputs['output_path']}/A_1_Arrets_Generiques.csv", sep=';', index = False)
            AP.to_csv(f"{user_inputs['output_path']}/A_2_Arrets_Physiques.csv", sep=';', index = False)
            ## Contrôle des nombres d'AP, AG
            nb_AP = str(len(AP))
            nb_AG = str(len(AG))
            self.dlg.progressBar.setValue(10)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création des table A_1_Arrets_Generiques et A_2_Arrets_Physiques terminée.")
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Les arrêts génériques sont générés avec {marker}.")
            self.dlg.progressText.append(f"Nombre d'arrêts génériques: {nb_AG}")
            self.dlg.progressText.append(f"Nombre d'arrêts physiques: {nb_AP}")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création des table A_1_Arrets_Generiques et A_2_Arrets_Physiques: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")      
         


        # Create table ligne
        try:
            lignes = ligne_generate(routes)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table lignes (avant mise en forme) terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table lignes (avant mise en forme): {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")    
        
        # Create itineraire
        try: 
            itineraire = itineraire_generate(stop_times, AP, trips)
            ## Affichage
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table itinéraires (avant mise en forme) terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table itineraire (avant mise en forme): {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}") 

        # Bar de progression
        self.dlg.progressBar.setValue(20)

        del stop_times    

        # Create itineraire arc
        try: 
            itineraire_arc = itiarc_generate(itineraire,AG)
            ## Affichage
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table itineraire_arc terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table itineraire_arc (avant mise en forme): {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}") 

        # Bar de progression
        self.dlg.progressBar.setValue(25)

        # Create courses
        try:
            courses = course_generate(itineraire,itineraire_arc)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table courses (avant mise en forme) terminé.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table courses (avant mise en forme): {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}") 

        # Bar de progression
        self.dlg.progressBar.setValue(30)

        # Create Sous lignes
        try:
            sous_ligne = sl_generate(courses, AG,lignes)
            sous_ligne.to_csv(f"{user_inputs['output_path']}/B_2_Sous_Lignes.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table B_2_Sous_Lignes terminées.")
            nb_sl = str(len(sous_ligne))
            self.dlg.progressText.append("Nombre de sous lignes : " +  nb_sl)
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table B_2_Sous_Lignes: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")   

        # Bar de progression
        self.dlg.progressBar.setValue(40)

        # Create service date et services jour type
        try:
            service_dates, msg = service_date_generate(calendar ,calendar_dates,Dates)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg}")
            service_dates_export = MEF_serdate(service_dates,ser_id_coor)
            service_dates_export.to_csv(f"{user_inputs['output_path']}/D_1_Service_Dates.csv", sep=';', index = False)
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table D_1_Service_Dates: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")   

        self.dlg.progressBar.setValue(45)

        try: 
            service_jour_type = service_jour_type_generate(service_dates,courses, user_inputs['type_vac'])
            service_jour_type_export = MEF_servjour(service_jour_type,route_id_coor,ser_id_coor,user_inputs['type_vac'])
            service_jour_type_export.to_csv(f"{user_inputs['output_path']}/D_2_Service_Jourtype.csv", sep=';', index = False)
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création de la table D_2_Service_Jourtype: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")   


        # mise en forme COURSES/ITINERAIRE/ITI_ARC en fonction du choix utilisateur
        try: 
            courses_export = MEF_course(courses, trip_id_coor)
            courses_export.to_csv(f"{user_inputs['output_path']}/C_1_Courses.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table C_1_Courses terminée.")
            itineraire_export = MEF_iti(itineraire,courses)
            itineraire_export.to_csv(f"{user_inputs['output_path']}/C_2_Itineraire.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table C_2_Itineraire terminée.")

            iti_arc_export = MEF_iti_arc(itineraire_arc,courses)
            iti_arc_export.to_csv(f"{user_inputs['output_path']}/C_3_Itineraire_Arc.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table C_3_Itineraire_Arc terminée.")
            # Ajouter information OD principal
            lignes_export = MEF_ligne(lignes,courses_export,AG)
            ## Ecriture en csv
            lignes_export.to_csv(f"{user_inputs['output_path']}/B_1_Lignes.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table B_1_Lignes terminée.")
            nb_lignes = str(len(lignes))
            self.dlg.progressText.append(f"Nombre de lignes: {nb_lignes}")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la lecture des données brutes pendant la mise en forme des tables ligne, courses, itinéraire, itinéraire_arc: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")   

        del routes
        ## Affichage
        self.dlg.progressBar.setValue(55)


        # Vérification s'il y a des relations multi-multi entre sous-ligne et shape_id
        try:
            sl_ayant_multi_shape, shape_ayant_multi_sl = DQ_shape(courses, trips)
            if len(sl_ayant_multi_shape) >0:
                warning_msg = f' Attention, les sous-lignes suivantes ont plusieurs shape_id\n{sl_ayant_multi_shape}'
                self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {warning_msg}")
                logger.exception(warning_msg)
            if len(shape_ayant_multi_sl) >0:
                warning_msg = f'Attention, les shape_id suivants correspont à plusieur sous-ligne\n{shape_ayant_multi_sl}'
                self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {warning_msg}")
                logger.exception(warning_msg)
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la vérification des données shapes: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")       


        # Créer les tracé des lignes QGIS
        layer_name = 'G_1_Trace_Sous_Ligne'
        try:
            shape_sl = geom_sous_ligne(courses, trips, shapes, sous_ligne)
            gdf_sl, gdf_ligne= create_linestring_shape(shape_sl,lignes_export,sous_ligne)
            gdf_sl.to_file(f"{user_inputs['output_path']}/G_1_Trace_Sous_Ligne.shp", driver="ESRI Shapefile")
            gdf_ligne.to_file(f"{user_inputs['output_path']}/G_2_Trace_Ligne.shp", driver="ESRI Shapefile")
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création des G1_Trace_Sous_Ligne et G2_Trace_Ligne-ligne terminées!")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de la création des tracés des lignes et sous-lignes: {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")   

        ## Affichage
        self.dlg.progressBar.setValue(65)

        # tables supplémentaires
        ## Création de la table nombre de passages par AG
        try:
            nb_passage_ag_typejour = nb_passage_ag(service_jour_type_export, itineraire_export, AG, user_inputs['type_vac'])
            nb_passage_ag_typejour.to_csv(f"{user_inputs['output_path']}/E_1_Nombre_Passage_AG.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table E_1_Nombre_Passage_AG terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de création de la table nb_passage_ag : {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")  

        ## Création de la table nombre de courses par ligne        
        try:
            nb_course_ligne_typejour = nb_course_ligne(service_jour_type_export, courses_export, user_inputs['type_vac'],lignes_export)
            nb_course_ligne_typejour.to_csv(f"{user_inputs['output_path']}/F_1_Nombre_Courses_Lignes.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table F_1_Nombre_Courses_Lignes terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de création de la table F_1_Nombre_Courses_Lignes : {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")  

        ## Création de la table fréquence des sous-ligne par période de la journée
        try:
            caract_sl = caract_par_sl(service_jour_type_export,courses_export,user_inputs['debut_hpm'] , user_inputs['fin_hpm'], 
                                    user_inputs['debut_hps'] ,user_inputs['fin_hps'], user_inputs['type_vac'],sous_ligne)
            caract_sl.to_csv(f"{user_inputs['output_path']}/F_2_Caract_SousLignes.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table F_2_Caract_SousLignes terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de création de la table F_2_Caract_SousLignes : {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")

        self.dlg.progressBar.setValue(70)

        ## KCC
        try:
            kcc_ligne = kcc_course_ligne(service_jour_type_export, courses_export,user_inputs['type_vac'], lignes_export, shapes_exist)
            kcc_ligne.to_csv(f"{user_inputs['output_path']}/F_3_KCC_Lignes.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table F_3_KCC_Lignes terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de création de la table F_3_KCC_Lignes : {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")

        try:
            kcc_sl = kcc_course_sl(service_jour_type_export, courses_export,user_inputs['type_vac'], sous_ligne, shapes_exist)
            kcc_sl.to_csv(f"{user_inputs['output_path']}/F_4_KCC_Sous_Ligne.csv", sep=';', index = False)
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création de la table F_4_KCC_Sous_Ligne terminée.")
        except Exception as e:
            nb_erreurs += 1
            msg_error = 'Exceptions lors de création de la table F_4_KCC_Sous_Ligne : {}'.format(e)
            logger.exception(msg_error) 
            self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: {msg_error}")         

        # Passage par AG sur QGIS
        # psg_ag = Qgs_PassageAG(nb_passage_ag_typejour,user_inputs['output_path'])
        nb_passage_ag_typejour['geometry'] = [Point(xy) for xy in zip(nb_passage_ag_typejour['stop_lon'],nb_passage_ag_typejour['stop_lat'])]
        # Create a GeoDataFrame with geometries
        gdf = gpd.GeoDataFrame(nb_passage_ag_typejour, geometry='geometry')
        gdf.crs = "EPSG:4326"
        # Write the GeoDataFrame to a shapefile
        gdf.to_file(f"{user_inputs['output_path']}/test_geopandas_stops.shp", driver="ESRI Shapefile")
        # QgsProject.instance().addMapLayer(psg_ag)
        # Rename the output layer with a custom name
        # custom_name = 'E_1_Nombre_Passage_AG'
        # psg_ag.setName(custom_name)

        # shapefileWriter(psg_ag, user_inputs['output_path'], custom_name)


        nb_passage_arc = passage_arc(iti_arc_export, service_jour_type, AG,user_inputs['type_vac'])
        nb_passage_arc['geometry'] = nb_passage_arc.apply(lambda row: LineString([(row['LON_x'], row['LAT_x']), (row['LON_y'], row['LAT_y'])]), axis=1)
        nb_passage_arc.to_csv(f"{user_inputs['output_path']}/E_4_Nombre_Passage_Arc.csv", sep=';', index = False)
        gdf = gpd.GeoDataFrame(nb_passage_arc, geometry='geometry')
        gdf.crs = "EPSG:4326"
        gdf.to_file(f"{user_inputs['output_path']}/test_geopandas_stops.shp", driver="ESRI Shapefile")
        
        # Passage par arc sur QGIS

        ## Affichage
        self.dlg.progressText.append(f"{datetime.now():%H:%M:%S}: Création des .shp pour passage AG/ARC terminées!")
        self.dlg.progressBar.setValue(75)

        t9 = time.time()
        success_message = f"Extraction terminée! Le petit a pris {round(t9 - t0)} seconds pour faire tout ce boulot sans erreur. Donne lui un bravo :)"
        fail_message = f"Extraction terminée! Le petit a pris {round(t9 - t0)} seconds pour faire tout ce boulot. Par contre, {nb_erreurs} erreurs sont apparues et méritent ton attention. Regarde le fichier .log pour plus d'info!"
        if nb_erreurs == 0:
            self.dlg.progressText.append(success_message)
            self.dlg.progressBar.setValue(100)
        else:
            self.dlg.progressText.append(fail_message)
            self.dlg.progressBar.setValue(66)            

    def test(self):
        pass

        




